clc; clear all; close all;

% Continue following this guide: https://se.mathworks.com/help/ident/ug/industrial-three-degrees-of-freedom-robot-c-mex-file-modeling-of-mimo-system-using-vector-matrix-parameters.html

metadata_filename = "data/metadata.json";
metadata = read_metadata(metadata_filename);
[full_state, full_input, t, maneuver_start_indices] = read_experiment_data(metadata);

% Load airframe properties
aircraft_properties;

% Create ID data from each experiment

[data] = create_iddata(full_state, full_input, maneuver_start_indices, t);

% figure('Name', [data.Name ': Elevator input -> Pitch rate output']);
% plot(data(:, 5, 1));   % Plot first input-output pair

parameters = create_lon_parameters();
% Initial state values
initial_states = struct(...
    'Name', {'q0', 'q1', 'q2', 'q3', 'q','u', 'w'},...
    'Unit', {'', '', '', '', 'rad/s', 'm/s', 'm/s'}, ...
    'Value', num2cell(data(1,:,:,1).OutputData), ...
    'Minimum', -Inf, 'Maximum', Inf, ...
    'Fixed', true);
[nlgr] = create_nlgr_object(parameters, initial_states);
%compare(data, nlgr);

%%



%compare(sysid_data, nlgr);
nlgr.SimulationOptions.Solver = 'ode4';
nlgr.SimulationOptions.FixedStep = 0.0001;
% GOAL:
%y = sim(nlgr, z);
fig = figure;
compare(z, nlgr);
%fig.Visible = 'off';
fig.Position = [100 100 1600 1000];
plot_output_location = "initial_guess/";
filename = "guess_" + 8;
saveas(fig, plot_output_location + filename, 'epsc')
    
    %predict(nlgr, sysid_data)
%%
opt = nlgreyestOptions();
opt.Display = 'on';
%opt.SearchMethod = 'lm';
opt.SearchOptions.MaxIterations = 5;
m2 = nlgreyest(z,nlgr,opt);

%%
predicted_state = y.y;
q_pred = predicted_state(:,1:4,:);
w_pred = predicted_state(:,5:7,:);
v_pred = predicted_state(:,8:10,:);
eul_pred = quat2eul(q_pred);

close all
figure
subplot(9,1,1)
plot(eul_pred(:,1)); hold on
plot(eul(:,1))
legend("yaw (estimated)", "yaw")

subplot(9,1,2)
plot(eul_pred(:,2)); hold on
plot(eul(:,2))
legend("pitch (estimated)", "pitch")

subplot(9,1,3)
plot(eul_pred(:,3)); hold on
plot(eul(:,3))
legend("roll (estimated)", "roll")

subplot(9,1,4)
plot(w_pred(:,1)); hold on
plot(w_B(:,1))
legend("p (estimated)", "p")

subplot(9,1,5)
plot(w_pred(:,2)); hold on
plot(w_B(:,2))
legend("q (estimated)", "q")

subplot(9,1,6)
plot(w_pred(:,3)); hold on
plot(w_B(:,3))
legend("r (estimated)", "r")

subplot(9,1,7)
plot(v_pred(:,1)); hold on
plot(v_B(:,1))
legend("u (estimated)", "u")

subplot(9,1,8)
plot(v_pred(:,2)); hold on
plot(v_B(:,2))
legend("v (estimated)", "v")

subplot(9,1,9)
plot(v_pred(:,3)); hold on
plot(v_B(:,3))
legend("w (estimated)", "w")



%figure('Name', [sysid_data.Name ': Aileron input -> Attitude output']);
%plot(sysid_data(:, 1:4, 5));   % Plot first input-output pair


%%


function [state, input, t, maneuver_start_indices] = read_experiment_data(metadata)
    num_experiments = length(metadata.Experiments);
    experiment_data_path = "data/experiments/";

    state = [];
    input = [];
    maneuver_start_indices = [];
    t = [];

    for i = 1:num_experiments
        datapath = experiment_data_path + "experiment_" + metadata.Experiments(i).Number ...
            + "/pitch_211_no_throttle/output/";
        if ~exist(datapath, 'dir')
            continue
        end
            
        state_exp = readmatrix(datapath + "state.csv");
        input_exp = readmatrix(datapath + "input.csv");
        maneuver_start_indices_exp = readmatrix(datapath + "maneuver_start_indices.csv");
        t_exp = readmatrix(datapath + "t.csv");

        state = [state;
                 state_exp];
        input = [input;
                 input_exp];
        maneuver_start_indices = [maneuver_start_indices...
            maneuver_start_indices_exp];
        t = [t;
             t_exp];
    end
    
    disp("Loaded " + length(maneuver_start_indices) + " maneuvers.")
end

function [data] = create_iddata(full_state, full_input, maneuver_start_indices, t)
    num_maneuvers = length(maneuver_start_indices);
    dt = t(2) - t(1);

    data = iddata('Name', 'Longitudinal data');

    % Describe input
    InputName = {'delta_e','delta_t_fw'};
    InputUnit =  {'rad', 'rpm'};

    % Describe state (which is equal to output)
    OutputName = {'q0', 'q1', 'q2', 'q3', 'q', 'u', 'w'};
    OutputUnit = {'', '', '', '', 'rad/s', 'm/s', 'm/s'};

    for i = 1:num_maneuvers
        if i == 1
            maneuver_start_index = 1;
        else
            maneuver_start_index = maneuver_start_indices(i - 1);
        end
        
        maneuver_end_index = maneuver_start_indices(i) - 1;

        % Extract only relevant maneuver data
        t_maneuver = t(maneuver_start_index:maneuver_end_index,:);
        full_state_maneuver = full_state(maneuver_start_index:maneuver_end_index,:);
        full_input_maneuver = full_input(maneuver_start_index:maneuver_end_index,:);

        quat = full_state_maneuver(:,1:4);
        q = full_state_maneuver(:,6);
        u = full_state_maneuver(:,8);
        w = full_state_maneuver(:,10);
        delta_e = full_input_maneuver(:,6);
        delta_t_fw = full_input_maneuver(:,8);

        state = [quat q u w];
        input = [delta_e delta_t_fw];

        % Create sysid data object
        z = iddata(state, input, dt, 'Name', 'Pitch 211 maneuvers');
        z.TimeUnit = 's';
        z.Tstart = 0;
        z.InputName = InputName;
        z.InputUnit = InputUnit;
        z.OutputName = OutputName;
        z.OutputUnit = OutputUnit;

        if i == 1
            data = z;
        else
            data = merge(data,z);
        end
    end
end

function [parameters] = create_lon_parameters()
    aircraft_properties;
    initial_guess_lon;
    approx_zero = eps;
    
    ParName = {
        'g',                ...
        'half_rho_planform', ...
        'mass',					...
        'mean_chord_length',              ...
        'wingspan',					...
        'nondim_constant_lon', ...
        'lam',				...
        'J_yy' ,            ...
        'c_L_0',				...
        'c_L_alpha',      	...
        'c_L_q',          	...
        'c_L_delta_e',    	...
        'c_D_p',				...
        'c_D_alpha',				...
        'c_D_alpha_sq',				...
        'c_D_q',          	...
        'c_D_delta_e',    	...
        'c_m_0',				...
        'c_m_alpha',          ...
        'c_m_q',				...
        'c_m_delta_e',		...
    };

    ParFixed = {
        true,... % g,                  ...
        true,... % half_rho_planform, ...
        true,... % mass_kg,					...
        true,... % mean_chord_length,              ...
        true,... % wingspan,					...
        true,... %nondim_constant_lon
        true,... % lam,				...
        true,... % Jyy, ...
        false,... % c_L_0,				...
        false,... % c_L_alpha,      	...
        false,... % c_L_q,          	...
        false,... % c_L_delta_e,    	...
        false,... % c_D_p,				...
        false,... % c_D_alpha,          ...
        false,... % c_D_alpha_sq,          ...
        false,... % c_D_q,          	...
        false,... % c_D_delta_e,    	...
        false,... % c_m_0,				...
        false,... % c_m_alpha,          ...
        false,... % c_m_q,				...
        false,... % c_m_delta_e,		...
    };

    ParMin = {
        -Inf,...
        -Inf,...
        -Inf,...
        -Inf,...
        -Inf,...
        -Inf,...
        -Inf,...
        -Inf,...
        approx_zero,... % c_L_0,				...
        approx_zero,... % c_L_alpha,      	...
        approx_zero,... % c_L_q,          	...
        approx_zero,... % c_L_delta_e,    	...
        approx_zero, ... % c_D_p,				...
        approx_zero, ...% c_D_alpha,          ...
        approx_zero, ...% c_D_alpha_sq,          ...
        approx_zero,... % c_D_q,          	...
        approx_zero,... % c_D_delta_e,    	...
        approx_zero,... % c_m_0,				...
        -Inf,... % c_m_alpha,          ...
        -Inf,... % c_m_q,				...
        -Inf,... % c_m_delta_e,		...
    };

    ParMax = {
        Inf,...
        Inf,...
        Inf,...
        Inf,...
        Inf,...
        Inf,...
        Inf,...
        Inf,...
        Inf,... % c_L_0,				...
        Inf,... % c_L_alpha,      	...
        Inf,... % c_L_q,          	...
        Inf,... % c_L_delta_e,    	...
        Inf, ... % c_D_p,				...
        Inf, ...% c_D_alpha,          ...
        Inf, ...% c_D_alpha_sq,          ...
        Inf,... % c_D_q,          	...
        Inf,... % c_D_delta_e,    	...
        Inf,... % c_m_0,				...
        -approx_zero,... % c_m_alpha,          ...
        -approx_zero,... % c_m_q,				...
        -approx_zero,... % c_m_delta_e,		...
    };

    ParValue = {
        g,                  ...
        half_rho_planform, ...
        mass_kg,					...
        mean_aerodynamic_chord_m,              ...
        wingspan_m,					...
        nondim_constant_lon, ...
        lam,				...
        Jyy, ...
        c_L_0,				...
        c_L_alpha,      	...
        c_L_q,          	...
        c_L_delta_e,    	...
        c_D_p,				...
        c_D_alpha,          ...
        c_D_alpha_sq,          ...
        c_D_q,          	...
        c_D_delta_e,    	...
        c_m_0,				...
        c_m_alpha,          ...
        c_m_q,				...
        c_m_delta_e,		...
    };


    parameters = struct('Name', ParName, ...
        'Unit', '',...
        'Value', ParValue, ...
        'Minimum', ParMin, ...
        'Maximum', ParMax, ...
        'Fixed', ParFixed);
end

function [nlgr] = create_nlgr_object(parameters, initial_states)
    % Create model
    FileName = 'longitudinal_model_c';
    Nx = 7; % number of states
    Ny = 7; % number of outputs
    Nu = 2; % number of inputs
    Order = [Ny Nu Nx];

    % Describe input
    InputName = {'delta_e','delta_t_fw'};
    InputUnit =  {'rad', 'rpm'};

    % Describe state (which is equal to output)
    OutputName = {'q0', 'q1', 'q2', 'q3', 'q', 'u', 'w'};
    OutputUnit = {'', '', '', '', 'rad/s', 'm/s', 'm/s'};



    % Construct nlgr object
    Ts = 0; % Continuous system
    nlgr = idnlgrey(FileName, Order, parameters, initial_states, Ts, ...
        'Name', 'Longitudinal Model', ...
        'InputName', InputName, 'InputUnit', InputUnit, ...
        'OutputName', OutputName, 'OutputUnit', OutputUnit, ...
        'TimeUnit', 's');
end