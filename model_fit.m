clc; clear all; close all;

% Continue following this guide: https://se.mathworks.com/help/ident/ug/industrial-three-degrees-of-freedom-robot-c-mex-file-modeling-of-mimo-system-using-vector-matrix-parameters.html

% Model parameters
aircraft_properties;

% Import data
% Data path
data_path = "dynamic_curves/longitudinal/";

input_output_data = readtable(data_path + 'output.csv');
c_L = readmatrix(data_path + 'c_L.csv');
c_D = readmatrix(data_path + 'c_D.csv');
AoA_rad = readmatrix(data_path + 'AoA_rad.csv');
AoA_deg = AoA_rad .* (180 / pi);
maneuver_length = readmatrix(data_path + 'maneuver_length.csv');
dt = readmatrix(data_path + 'dt.csv');
aggregated_maneuvers = readmatrix(data_path + 'aggregated_maneuvers.csv');
num_maneuvers = length(AoA_rad) / maneuver_length;

q_NB = [input_output_data.state_output_1 input_output_data.state_output_2 input_output_data.state_output_3 input_output_data.state_output_4];
w_B = [input_output_data.state_output_5 input_output_data.state_output_6 input_output_data.state_output_7];
v_B = [input_output_data.state_output_8 input_output_data.state_output_9 input_output_data.state_output_10];

%%
eul = quat2eul(q_NB);
eul_deg = rad2deg(eul);

aileron_input = input_output_data.input_output_5;
elevator_input = input_output_data.input_output_6;
rudder_input = input_output_data.input_output_7;
pusher_motor_input = input_output_data.input_output_8;


%%

rpm_pusher = calculate_rpm_pusher_motor(pusher_motor_input);
[aileron_angle_rad, elevator_angle_rad, rudder_angle_rad] = calculate_control_surface_angles(aileron_input, elevator_input, rudder_input);
u_fw = [aileron_angle_rad, elevator_angle_rad, rudder_angle_rad rpm_pusher];
u_mr = [input_output_data.input_output_1 input_output_data.input_output_2 input_output_data.input_output_3 input_output_data.input_output_4];

% Prepare data for sysid
state = [q_NB w_B v_B];
input = [u_mr u_fw];

%% Create nonlinear grey box model

%%%%%
% Model parameters
%%%%%

FileName = 'vtol_linear_c';
Nx = 10; % number of states
Ny = 10; % number of outputs
Nu = 8; % number of inputs
Order = [Ny Nu Nx];

%%%%%
% Constants
%%%%%

% Import airframe constants
aircraft_properties;

m = mass_kg;
chord = mean_chord_length_m;
b = wingspan_m;
r_t1 = r_t1_B;
r_t2 = r_t2_B;
r_t3 = r_t3_B;
r_t4 = r_t4_B;

%%%%%
% Parameters
%%%%%

rng(1); % Always same random numbers

% Import initial guesses for static curves
lift_drag_properties;
rho_diam_top_pwr_four = rho * prop_diam_top ^ 4; % computed once for efficiency
rho_diam_pusher_pwr_four = rho * prop_diam_pusher ^ 4; % computed once for efficiency
rho_diam_top_pwr_five = rho * prop_diam_top ^ 5; % computed once for efficiency
rho_diam_pusher_pwr_five = rho * prop_diam_pusher ^ 5; % computed once for efficiency
half_rho_planform = 0.5 * rho * planform_sqm; % computed once for efficiency

% Lift parameters
eps = 0.1;
c_L_q = rand_num_in_interval(-1, 1);
c_L_delta_e = rand_num_in_interval(-1, 1);

% Y-aerodynamic force
c_Y_p = rand_num_in_interval(-eps, eps);
c_Y_r = rand_num_in_interval(-eps, eps);
c_Y_delta_a = rand_num_in_interval(-eps, eps);
c_Y_delta_r = rand_num_in_interval(-eps, eps);

% Aerodynamic moment around x axis
c_l_p = rand_num_in_interval(-1, 0); % Dynamic damping derivative, should be negative
c_l_r = rand_num_in_interval(-eps, eps); % Cross coupling
c_l_delta_a = rand_num_in_interval(0, 1); % Control derivative, should be positive to follow PX4 convention
c_l_delta_r = rand_num_in_interval(-eps, eps); % Cross-control derivative

% Aerodynamic moment around y axis
c_m_0 = rand_num_in_interval(-1, 1);
c_m_alpha = rand_num_in_interval(-1, 0); % Spring coefficient. Should be negative for stable aircraft
c_m_q = rand_num_in_interval(-1, 0); % Dynamic damping derivative. Should be negative
c_m_delta_e = rand_num_in_interval(0, 1); % Control derivative. Should be positive to follow PX4 convention

% Aerodynamic moment around z axis
c_n_p = rand_num_in_interval(-eps, eps); % Cross coupling
c_n_r = rand_num_in_interval(-1, 0); % Dynamic damping derivative. Should be negative
c_n_delta_a = rand_num_in_interval(-eps, eps); % Cross-control derivative
c_n_delta_r = rand_num_in_interval(0, 1); % Control derivative. Should be positive to follow PX4 convention

% Build model
ParName = {
    'g',                ...
    'rho_diam_top_pwr_four', ...
    'rho_diam_pusher_pwr_four', ...
    'rho_diam_top_pwr_five', ...
    'rho_diam_pusher_pwr_five', ...
    'half_rho_planform', ...
    'c_F_top',			...
    'c_F_pusher',         ...
    'c_Q_top',			...
    'c_Q_pusher',         ...
    'm',					...
    'chord',              ...
    'b',					...
    'lam',				...
    'J_yy' ,            ...
    'r_t1',               ...
    'r_t2',				...
    'r_t3',				...
    'r_t4'				...
    'c_L_0',				...
    'c_L_alpha',      	...
    'c_L_q',          	...
    'c_L_delta_e',    	...
    'c_D_p',				...
    'c_D_alpha',				...
    'c_Y_p',				...
    'c_Y_r',				...
    'c_Y_delta_a',		...
    'c_Y_delta_r',		...
    'c_l_p',              ...
    'c_l_r',				...
    'c_l_delta_a',		...
    'c_l_delta_r',        ...
    'c_m_0',				...
    'c_m_alpha',          ...
    'c_m_q',				...
    'c_m_delta_e',		...
    'c_n_p',				...
    'c_n_r',				...
    'c_n_delta_a',		...
    'c_n_delta_r',        ...
};

ParValue = {
    g,                  ...
    rho_diam_top_pwr_four, ...
    rho_diam_pusher_pwr_four, ...
    rho_diam_top_pwr_five, ...
    rho_diam_pusher_pwr_five, ...
    half_rho_planform, ...
    c_T_top,			...
    c_T_pusher,         ...
    c_Q_top,			...
    c_Q_pusher,         ...
    m,					...
    chord,              ...
    b,					...
    lam,				...
    Jyy, ...
    r_t1,               ...
    r_t2,				...
    r_t3,				...
    r_t4,				...
    c_L_0,				...
    c_L_alpha,      	...
    c_L_q,          	...
    c_L_delta_e,    	...
    c_D_p,				...
    c_D_alpha,          ...
    c_Y_p,				...
    c_Y_r,				...
    c_Y_delta_a,		...
    c_Y_delta_r,		...
    c_l_p,              ...
    c_l_r,				...
    c_l_delta_a,		...
    c_l_delta_r,        ...
    c_m_0,				...
    c_m_alpha,          ...
    c_m_q,				...
    c_m_delta_e,		...
    c_n_p,				...
    c_n_r,				...
    c_n_delta_a,		...
    c_n_delta_r        ...
};

ParUnit = {
    'm/s^2',    ...
    '', ...
    '', ...
    '', ...
    '', ...
    '', ...
    '',			...
    '',			...
    '',			...
    '',			...
    'kg',			...
    'm',		...
    'm',		...
    '',			...
    '', ...
    'm',		...
    'm',		...
    'm',		...
    'm',		...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    ''
};
ParFixed = {
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
};

% TODO set parameter max and min
ParMin = -Inf;
ParMax   = Inf;

Parameters    = struct('Name', ParName, 'Unit', ParUnit, 'Value', ParValue, ...
                       'Minimum', ParMin, 'Maximum', ParMax, 'Fixed', ParFixed);
                   
% Initial values
state_initial = state(1,:);

InitialStates = struct(...
    'Name', {'q0', 'q1', 'q2', 'q3', 'p', 'q', 'r', 'u', 'v', 'w'},...
    'Unit', {'', '', '', '', 'rad/s', 'rad/s', 'rad/s', 'm/s', 'm/s', 'm/s'}, ...
    'Value', {state(1,1), state(1,2), state(1,3), state(1,4), ...
        state(1,5), state(1,6), state(1,7), ...
        state(1,8), state(1,9), state(1,10)}, ...
    'Minimum', -Inf, 'Maximum', Inf, 'Fixed', false);
         
Ts = 0;

nlgr = idnlgrey(FileName,Order,Parameters, InitialStates, Ts, ...
    'Name', 'VTOL_aircraft');

%% Create sysid data object

sysid_data = iddata(state, input, dt, 'Name', 'VTOL-roll');

sysid_data.InputName = {'nt1', 'nt2', 'nt3', 'nt4',...
    'delta_a', 'delta_e', 'delta_r', 'np'};
sysid_data.InputUnit =  {'rpm', 'rpm', 'rpm', 'rpm', ...
    'rpm', 'rad', 'rad', 'rad'};
sysid_data.OutputName = {'q0', 'q1', 'q2', 'q3', ...
    'p', 'q', 'r', 'u', 'v', 'w'};
sysid_data.OutputUnit = {'', '', '', '', 'rad/s', 'rad/s', 'rad/s', ...
    'm/s', 'm/s', 'm/s'};
sysid_data.Tstart = 0;
sysid_data.TimeUnit = 's';

%figure('Name', [sysid_data.Name ': Aileron input -> Attitude output']);
%plot(sysid_data(:, 1:4, 5));   % Plot first input-output pair

%%

%compare(sysid_data, nlgr);

% GOAL:
y = sim(nlgr, sysid_data);
predicted_state = y.y;
q_pred = predicted_state(:,1:4,:);
w_pred = predicted_state(:,5:7,:);
v_pred = predicted_state(:,8:10,:);
eul_pred = quat2eul(q_pred);

figure
subplot(3,1,1)
plot(eul_pred(:,1)); hold on
plot(eul(:,1))
legend("yaw", "yaw (estimated)")

subplot(3,1,2)
plot(eul_pred(:,2)); hold on
plot(eul(:,2))
legend("pitch", "pitch (estimated)")

subplot(3,1,3)
plot(eul_pred(:,3)); hold on
plot(eul(:,3))
legend("roll", "roll (estimated)")


%figure('Name', [sysid_data.Name ': Aileron input -> Attitude output']);
%plot(sysid_data(:, 1:4, 5));   % Plot first input-output pair

%%

function [r] = rand_num_in_interval(min, max)
    r = min + (max - min) * rand();
end
