clc; clear all; close all;

% Continue following this guide: https://se.mathworks.com/help/ident/ug/industrial-three-degrees-of-freedom-robot-c-mex-file-modeling-of-mimo-system-using-vector-matrix-parameters.html

% Model parameters
aircraft_properties;

% Import data
% Data path
data_path = "dynamic_curves/longitudinal/";

input_output_data = readtable(data_path + 'output.csv');
c_L = readmatrix(data_path + 'c_L.csv');
c_D = readmatrix(data_path + 'c_D.csv');
AoA_rad = readmatrix(data_path + 'AoA_rad.csv');
AoA_deg = AoA_rad .* (180 / pi);
maneuver_length = readmatrix(data_path + 'maneuver_length.csv');
dt = readmatrix(data_path + 'dt.csv');
aggregated_maneuvers = readmatrix(data_path + 'aggregated_maneuvers.csv');
num_maneuvers = length(AoA_rad) / maneuver_length;

q_NB = [input_output_data.state_output_1 input_output_data.state_output_2 input_output_data.state_output_3 input_output_data.state_output_4];
w_B = [input_output_data.state_output_5 input_output_data.state_output_6 input_output_data.state_output_7];
v_B = [input_output_data.state_output_8 input_output_data.state_output_9 input_output_data.state_output_10];


eul = quat2eul(q_NB);
eul_deg = rad2deg(eul);

aileron_input = input_output_data.input_output_5;
elevator_input = input_output_data.input_output_6;
rudder_input = input_output_data.input_output_7;
pusher_motor_input = input_output_data.input_output_8;



rpm_pusher = calculate_rpm_pusher_motor(pusher_motor_input);
[aileron_angle_rad, elevator_angle_rad, rudder_angle_rad] = calculate_control_surface_angles(aileron_input, elevator_input, rudder_input);
u_fw = [aileron_angle_rad, elevator_angle_rad, rudder_angle_rad rpm_pusher];
u_mr = [input_output_data.input_output_1 input_output_data.input_output_2 input_output_data.input_output_3 input_output_data.input_output_4];

% Prepare data for sysid
state = [q_NB w_B v_B];
input = [u_mr u_fw];

%% Create nonlinear grey box model

%%%%%
% Model parameters
%%%%%

FileName = 'vtol_linear_c';
Nx = 10; % number of states
Ny = 10; % number of outputs
Nu = 8; % number of inputs
Order = [Ny Nu Nx];

%%%%%
% Constants
%%%%%

% Import airframe constants
aircraft_properties;

m = mass_kg;
chord = mean_chord_length_m;
b = wingspan_m;
r_t1 = r_t1_B;
r_t2 = r_t2_B;
r_t3 = r_t3_B;
r_t4 = r_t4_B;

%%%%%
% Parameters
%%%%%

rng(1); % Always same random numbers

% Import initial guesses for static curves
lift_drag_properties;
rho_diam_top_pwr_four = rho * prop_diam_top ^ 4; % computed once for efficiency
rho_diam_pusher_pwr_four = rho * prop_diam_pusher ^ 4; % computed once for efficiency
rho_diam_top_pwr_five = rho * prop_diam_top ^ 5; % computed once for efficiency
rho_diam_pusher_pwr_five = rho * prop_diam_pusher ^ 5; % computed once for efficiency
half_rho_planform = 0.5 * rho * planform_sqm; % computed once for efficiency

% % Lift parameters
% eps = 0.01;
% c_L_q = rand_num_in_interval(-eps, eps);
% c_L_delta_e = rand_num_in_interval(-eps, eps);
% 
% % Y-aerodynamic force
% c_Y_p = rand_num_in_interval(-eps, eps);
% c_Y_r = rand_num_in_interval(-eps, eps);
% c_Y_delta_a = rand_num_in_interval(-eps, eps);
% c_Y_delta_r = rand_num_in_interval(-eps, eps);
% 
% % Aerodynamic moment around x axis
% c_l_p = rand_num_in_interval(-1, 0); % Dynamic damping derivative, should be negative
% c_l_r = rand_num_in_interval(-eps, eps); % Cross coupling
% c_l_delta_a = rand_num_in_interval(0, 1); % Control derivative, should be positive to follow PX4 convention
% c_l_delta_r = rand_num_in_interval(-eps, eps); % Cross-control derivative
% 
% % Aerodynamic moment around y axis
% c_m_0 = rand_num_in_interval(-1, 1);
% c_m_alpha = rand_num_in_interval(-1, 0); % Spring coefficient. Should be negative for stable aircraft
% c_m_q = rand_num_in_interval(-1, 0); % Dynamic damping derivative. Should be negative
% c_m_delta_e = rand_num_in_interval(0, 1); % Control derivative. Should be positive to follow PX4 convention
% 
% % Aerodynamic moment around z axis
% c_n_p = rand_num_in_interval(-eps, eps); % Cross coupling
% c_n_r = rand_num_in_interval(-1, 0); % Dynamic damping derivative. Should be negative
% c_n_delta_a = rand_num_in_interval(-eps, eps); % Cross-control derivative
% c_n_delta_r = rand_num_in_interval(0, 1); % Control derivative. Should be positive to follow PX4 convention

% Parameters from Aerosonde UAV
% Lift parameters
c_L_q = 0;
c_L_delta_e = -0.36;

% Y-aerodynamic force
c_Y_p = 0;
c_Y_r = 0;
c_Y_delta_a = 0;
c_Y_delta_r = -0.17;

% Aerodynamic moment around x axis
c_l_p = -0.26;
c_l_r = 0.14;
c_l_delta_a = 0.08;
c_l_delta_r = 0.105;

% Aerodynamic moment around y axis
c_m_0 = -0.02;
c_m_alpha = -0.38;
c_m_q = -0.5;
c_m_delta_e = 1;

% Aerodynamic moment around z axis
c_n_p = 0.022;
c_n_r = -0.35;
c_n_delta_a = 0.06;
c_n_delta_r = 0.032;


%%

% Build model
ParName = {
    'g',                ...
    'rho_diam_top_pwr_four', ...
    'rho_diam_pusher_pwr_four', ...
    'rho_diam_top_pwr_five', ...
    'rho_diam_pusher_pwr_five', ...
    'half_rho_planform', ...
    'c_F_top',			...
    'c_F_pusher',         ...
    'c_Q_top',			...
    'c_Q_pusher',         ...
    'm',					...
    'chord',              ...
    'b',					...
    'lam',				...
    'J_yy' ,            ...
    'r_t1',               ...
    'r_t2',				...
    'r_t3',				...
    'r_t4'				...
    'c_L_0',				...
    'c_L_alpha',      	...
    'c_L_q',          	...
    'c_L_delta_e',    	...
    'c_D_p',				...
    'c_D_alpha',				...
    'c_Y_p',				...
    'c_Y_r',				...
    'c_Y_delta_a',		...
    'c_Y_delta_r',		...
    'c_l_p',              ...
    'c_l_r',				...
    'c_l_delta_a',		...
    'c_l_delta_r',        ...
    'c_m_0',				...
    'c_m_alpha',          ...
    'c_m_q',				...
    'c_m_delta_e',		...
    'c_n_p',				...
    'c_n_r',				...
    'c_n_delta_a',		...
    'c_n_delta_r',        ...
};

ParValue = {
    g,                  ...
    rho_diam_top_pwr_four, ...
    rho_diam_pusher_pwr_four, ...
    rho_diam_top_pwr_five, ...
    rho_diam_pusher_pwr_five, ...
    half_rho_planform, ...
    c_T_top,			...
    c_T_pusher,         ...
    c_Q_top,			...
    c_Q_pusher,         ...
    m,					...
    chord,              ...
    b,					...
    lam,				...
    Jyy, ...
    r_t1,               ...
    r_t2,				...
    r_t3,				...
    r_t4,				...
    c_L_0,				...
    c_L_alpha,      	...
    c_L_q,          	...
    c_L_delta_e,    	...
    c_D_p,				...
    c_D_alpha,          ...
    c_Y_p,				...
    c_Y_r,				...
    c_Y_delta_a,		...
    c_Y_delta_r,		...
    c_l_p,              ...
    c_l_r,				...
    c_l_delta_a,		...
    c_l_delta_r,        ...
    c_m_0,				...
    c_m_alpha,          ...
    c_m_q,				...
    c_m_delta_e,		...
    c_n_p,				...
    c_n_r,				...
    c_n_delta_a,		...
    c_n_delta_r        ...
};

ParUnit = {
    'm/s^2',    ...
    '', ...
    '', ...
    '', ...
    '', ...
    '', ...
    '',			...
    '',			...
    '',			...
    '',			...
    'kg',			...
    'm',		...
    'm',		...
    '',			...
    '', ...
    'm',		...
    'm',		...
    'm',		...
    'm',		...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    '',			...
    ''
};
ParFixed = {
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ...
    true, ... % r_t4
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
    false, ...
};

% TODO set parameter max and min
ParMin = {
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,...
    -Inf,... 
    -Inf, ...
    -Inf, ...
    -Inf, ... % rt_4
     0,... % c_L_0,				...
     0,... % c_L_alpha,      	...
    -Inf,...           % c_L_q,          	...
    % c_L_delta_e,    	...
    % c_D_p,				...
    % c_D_alpha,          ...
    % c_Y_p,				...
    % c_Y_r,				...
    % c_Y_delta_a,		...
    % c_Y_delta_r,		...
    % c_l_p,              ...
    % c_l_r,				...
    % c_l_delta_a,		...
    % c_l_delta_r,        ...
    % c_m_0,				...
    % c_m_alpha,          ...
    % c_m_q,				...
    % c_m_delta_e,		...
    % c_n_p,				...
    % c_n_r,				...
    % c_n_delta_a,		...
    % c_n_delta_r        ...
}-Inf;
ParMax   = Inf;

Parameters    = struct('Name', ParName, ...
    'Unit', ParUnit, ...
    'Value', ParValue, ...
    'Minimum', ParMin, ...
    'Maximum', ParMax, ...
    'Fixed', ParFixed);
                   
% Initial values
state_initial = state(1,:);

InitialStates = struct(...
    'Name', {'q0', 'q1', 'q2', 'q3', 'p', 'q', 'r', 'u', 'v', 'w'},...
    'Unit', {'', '', '', '', 'rad/s', 'rad/s', 'rad/s', 'm/s', 'm/s', 'm/s'}, ...
    'Value', {state(1,1), state(1,2), state(1,3), state(1,4), ...
        state(1,5), state(1,6), state(1,7), ...
        state(1,8), state(1,9), state(1,10)}, ...
    'Minimum', -Inf, 'Maximum', Inf, ...
    'Fixed', true); % Fix initial values
         
Ts = 0;

nlgr = idnlgrey(FileName,Order,Parameters, InitialStates, Ts, ...
    'Name', 'VTOL_aircraft');

% nlgr.SimulationOptions.Solver = 'ode4';
% nlgr.SimulationOptions.RelTol = 1e-2;
% nlgr.SimulationOptions.FixedStep = 1e-3;

% Create sysid data object

sysid_data = iddata(state, input, dt, 'Name', 'VTOL-roll');

sysid_data.InputName = {'nt1', 'nt2', 'nt3', 'nt4',...
    'delta_a', 'delta_e', 'delta_r', 'np'};
sysid_data.InputUnit =  {'rpm', 'rpm', 'rpm', 'rpm', ...
    'rpm', 'rad', 'rad', 'rad'};
sysid_data.OutputName = {'q0', 'q1', 'q2', 'q3', ...
    'p', 'q', 'r', 'u', 'v', 'w'};
sysid_data.OutputUnit = {'', '', '', '', 'rad/s', 'rad/s', 'rad/s', ...
    'm/s', 'm/s', 'm/s'};
sysid_data.Tstart = 0;
sysid_data.TimeUnit = 's';

%figure('Name', [sysid_data.Name ': Aileron input -> Attitude output']);
%plot(sysid_data(:, 1:4, 5));   % Plot first input-output pair

%%

%compare(sysid_data, nlgr);

% GOAL:
%y = sim(nlgr, sysid_data);
%predict(nlgr, sysid_data)

opt = nlgreyestOptions();
opt.Display = 'on';
opt.SearchOptions.MaxIterations = 4;
m2 = nlgreyest(sysid_data,nlgr,opt);

%%
predicted_state = y.y;
q_pred = predicted_state(:,1:4,:);
w_pred = predicted_state(:,5:7,:);
v_pred = predicted_state(:,8:10,:);
eul_pred = quat2eul(q_pred);

close all
figure
subplot(9,1,1)
plot(eul_pred(:,1)); hold on
plot(eul(:,1))
legend("yaw (estimated)", "yaw")

subplot(9,1,2)
plot(eul_pred(:,2)); hold on
plot(eul(:,2))
legend("pitch (estimated)", "pitch")

subplot(9,1,3)
plot(eul_pred(:,3)); hold on
plot(eul(:,3))
legend("roll (estimated)", "roll")

subplot(9,1,4)
plot(w_pred(:,1)); hold on
plot(w_B(:,1))
legend("p (estimated)", "p")

subplot(9,1,5)
plot(w_pred(:,2)); hold on
plot(w_B(:,2))
legend("q (estimated)", "q")

subplot(9,1,6)
plot(w_pred(:,3)); hold on
plot(w_B(:,3))
legend("r (estimated)", "r")

subplot(9,1,7)
plot(v_pred(:,1)); hold on
plot(v_B(:,1))
legend("u (estimated)", "u")

subplot(9,1,8)
plot(v_pred(:,2)); hold on
plot(v_B(:,2))
legend("v (estimated)", "v")

subplot(9,1,9)
plot(v_pred(:,3)); hold on
plot(v_B(:,3))
legend("w (estimated)", "w")



%figure('Name', [sysid_data.Name ': Aileron input -> Attitude output']);
%plot(sysid_data(:, 1:4, 5));   % Plot first input-output pair

%%

function [r] = rand_num_in_interval(min, max)
    r = min + (max - min) * rand();
end
